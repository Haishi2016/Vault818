<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hello, World!</title>
        <style>
            body {margin:0;}
            canvas {width:100%; height:100%}
        </style>
    </head>
    <body>
		<script src="three.js"></script>
		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				
				gl_Position = projectionMatrix * mvPosition;
				//if (gl_Position.x <= 50.0) {
					gl_PointSize = size * ( 300.0 / -mvPosition.z );
				//} else {
				//	gl_Position.x = 1000.0;
				//	gl_PointSize = 0.0;
				//}
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4(color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
		</script>
        <script>
            var camera, scene, renderer;
			var mesh;
			var rings = [];
			var startingY = 140;
			var startingScale = 2;
			var closeStep = 2;
			var particles = 3000;
			var uniforms;
			var shaderMaterial;
			init();
			animate();
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;
				camera.position.y = 200;
				camera.position.x = -100;
				camera.lookAt(new THREE.Vector3(-200,0,0));
				scene = new THREE.Scene();

				uniforms = {
					color:     { value: new THREE.Color( 0xffffff ) },
					texture:   { value: new THREE.TextureLoader().load( "texture/spark1.png" ) }
				};

				shaderMaterial = new THREE.ShaderMaterial( {
					uniforms:       uniforms,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					blending:       THREE.AdditiveBlending,
					depthTest:      true,
					depthWrite:     false,
					transparent:    true
				});

				
				addRing(250, 20, 1);
				addRing(270, 20, 1);
				addRing(290, 20, 1);
				addRing(310, startingY, startingScale);
				
							var saturnMatrial = new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load( 'texture/saturn.png' )});
				var geometry = new THREE.SphereGeometry( 200, 200, 200 );
				mesh = new THREE.Mesh( geometry, saturnMatrial);
				scene.add( mesh );


				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				mesh.rotation.y -= 0.01;
				rings.forEach((r)=>{
					//r.rotation.y -= 0.01;
					if (r.particleSystem.position.y > 20)
						r.particleSystem.position.y -= closeStep;
					//if (r.scale.x > 1){
					//	r.scale.x -= (startingScale-1) * closeStep/(startingY-20);
					//	r.scale.z -= (startingScale-1) * closeStep/(startingY-20);
					//}
					r.particleSystem.rotation.y -=0.01;
				});
				//particleSystem.rotation.y -=0.01;
				renderer.render( scene, camera );

			}
			function turnOffRing(index)
			{
				rings.splice(index,1);
			}
			function addRing(radius, y, scale){
				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array( particles * 3 );
				var colors = new Float32Array( particles * 3 );
				var sizes = new Float32Array( particles );
				var color = new THREE.Color();
				for ( var i = 0, i3 = 0; i < particles; i ++, i3 += 3 ) {
					var angle = Math.random() * Math.PI * 2;
					var ringSize= Math.random() * 20 + radius;
					positions[ i3 + 0 ] = ringSize * Math.cos(angle);
					positions[ i3 + 1 ] = 0;
					positions[ i3 + 2 ] = ringSize * Math.sin(angle);

					color.setHSL( i / particles, 1.0, 0.5 );
					colors[ i3 + 0 ] = 255.0; //color.r;
					colors[ i3 + 1 ] = 255.0; //color.g;
					colors[ i3 + 2 ] = 255.0; //color.b;
					sizes[ i ] = 20;
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
				var particleSystem = new THREE.Points( geometry, shaderMaterial );
				particleSystem.position.y = y;
				scene.add( particleSystem );
				rings.push({
					geometry:geometry,
					particleSystem:particleSystem
				})
			}
			
        </script>
    </body>
</html>