<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hello, World!</title>
        <style>
            body {margin:0;}
            canvas {width:100%; height:100%}
        </style>
    </head>
    <body>
		<script src="three.js"></script>
		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				gl_Position = projectionMatrix * mvPosition;
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4(color * vColor, 0.5 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
		</script>
        <script>
            var camera, scene, renderer;
			var mesh;
			var rings = [];
			var startingY = 140;
			var startingScale = 2;
			var closeStep = 2;
			var particles = 8000;
			var uniforms;
			var shaderMaterial;
			var nodes = [];
			var rotationSpeed = 0.005;
			var stage = 0;
			var closestRing = 250;
			init();
			animate();
			refreshData();
			function refreshData()
			{
				if (stage == 0){
					nodes = [10,20,30,40,50,40,40,40, 50, 50, 50];
					stage++;
				} else if (stage == 5) {
					nodes = [10,20,0,40,50,40,40,40, 50, 50, 50];
					stage++;
				} else if (stage == 10) {
					nodes = [10,20,20,40,50,40,40,40, 50, 50, 50];
					stage = 0;
				} else
					stage++;
				for (var i = 0; i < nodes.length; i++){
					if (!rings[i])
						addRing(closestRing + i * 25, startingY,startingScale);
					else{
						if (nodes[i] == 0){
							if (!rings[i].broken)
							{
								breakRing(i, closestRing + i * 25, 20, 1);
							}
						}
						else {
							if (rings[i].broken)
								healRing(i, closestRing + i * 25, 20, 1);
							else
								updateRing(i);
						}
					}
				}
				//addRing(250, startingY,startingScale);
				//addRing(270, startingY, startingScale);
				//addRing(290, startingY, startingScale);
				//addRing(310, startingY, startingScale);
				setTimeout(refreshData, 1000);
			}
			function healRing(index, radius, y, scale){
				//var ring = makeRing(radius, y, scale, false);
				//scene.remove(rings[index].particleSystem );
				//rings[index].particleSystem = ring.particleSystem;
				rings[index].broken = false; 
				//scene.add(rings[index].particleSystem);
			}
			function breakRing(index, radius, y, scale){
				//var ring = makeRing(radius, y, scale, true);
				//scene.remove(rings[index].particleSystem );
				//rings[index].particleSystem = ring.particleSystem;
				rings[index].broken = true; 
				//scene.add(rings[index].particleSystem);
			}
			function updateRing(index){

			}
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;
				camera.position.y = 200;
				camera.position.x = -100;
				camera.lookAt(new THREE.Vector3(-200,0,0));
				scene = new THREE.Scene();

				uniforms = {
					color:     { value: new THREE.Color( 0xffffff ) },
					texture:   { value: new THREE.TextureLoader().load( "texture/spark1.png" ) }
				};

				shaderMaterial = new THREE.ShaderMaterial( {
					uniforms:       uniforms,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					blending:       THREE.AdditiveBlending,
					depthTest:      true,
					depthWrite:     false,
					transparent:    true
				});

				var saturnMatrial = new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load( 'texture/saturn.png' )});
				var geometry = new THREE.SphereBufferGeometry( 200, 200, 200 );
				mesh = new THREE.Mesh( geometry, saturnMatrial);
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				scene.add( mesh );

				var planeGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 320, 320 );
				var planeMaterial = new THREE.ShadowMaterial( { color: 0x00ff00 } )
				var plane = new THREE.Mesh( planeGeometry, planeMaterial );
				plane.receiveShadow = true;
				plane.rotation.x = -Math.PI / 2;
				plane.position.y = 20;
				scene.add( plane );

				var spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.position.set( -300, 300, 500 );
				spotLight.shadow.mapSize.width = 5120;  // default
				spotLight.shadow.mapSize.height = 5120; // default
				spotLight.shadow.camera.near = 0.5;       // default
				spotLight.shadow.camera.far = 50000      // default

				scene.add( spotLight );				

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
								
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				var time = Date.now() * 0.005;
				requestAnimationFrame( animate );
				mesh.rotation.y -= rotationSpeed;
				rings.forEach((r)=>{
					if (r.particleSystem.position.y > 20)
						r.particleSystem.position.y -= closeStep;
					if (r.particleSystem.scale.x > 1){
						r.particleSystem.scale.x -= (startingScale-1) * closeStep/(startingY-20);
						r.particleSystem.scale.z -= (startingScale-1) * closeStep/(startingY-20);
					}					
					r.particleSystem.rotation.y -=rotationSpeed;
					var sizes = r.geometry.attributes.size.array;
					for ( var i = 0; i < particles; i++ ) {
						sizes[ i ] = 15 * ( 1 + Math.sin( 0.1 * i + time ) );
					}
					r.geometry.attributes.size.needsUpdate = true;					
					var colors = r.geometry.attributes.customColor.array;
					for (var j = 0; j < 100; j++) {
						var i = Math.floor(Math.random() * particles);
						var col = Math.random() * 255.0;
						if (r.broken){
							colors[ i*3+ 0] = col;
							colors[ i*3+ 1] = 0.0;
							colors[ i*3+ 2] = 0.0;
						} else {
							colors[ i*3+ 0] = col;
							colors[ i*3+ 1] = col;
							colors[ i*3+ 2] = col;
						}
					}
					r.geometry.attributes.customColor.needsUpdate = true;					
					
				});
				renderer.render( scene, camera );
			}
	
			function addRing(radius, y, scale){
				var ring = makeRing(radius, y, scale, false);
				scene.add( ring.particleSystem );
				rings.push(ring);
			}
			function makeRing(radius, y, scale, broken){
				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array( particles * 3 );
				var colors = new Float32Array( particles * 3 );
				var sizes = new Float32Array( particles );
				var color = new THREE.Color();
				for ( var i = 0, i3 = 0; i < particles; i ++, i3 += 3 ) {
					var angle = Math.random() * Math.PI * 2;
					var ringSize= Math.random() * 20 + radius;
					positions[ i3 + 0 ] = ringSize * Math.cos(angle);
					positions[ i3 + 1 ] = 0;
					positions[ i3 + 2 ] = ringSize * Math.sin(angle);

					color.setHSL( i / particles, 1.0, 0.5 );
					var col = Math.random() * 255.0;
					if (broken) {
						colors[ i3 + 0 ] = col; //color.r;
						colors[ i3 + 1 ] = 0.0; //color.g;
						colors[ i3 + 2 ] = 0.0; //color.b;
					} else {
						colors[ i3 + 0 ] = col; //color.r;
						colors[ i3 + 1 ] = col; //color.g;
						colors[ i3 + 2 ] = col; //color.b;
					}
					sizes[ i ] = 20;
				}
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
				var particleSystem = new THREE.Points( geometry, shaderMaterial );
				particleSystem.position.y = y;
				particleSystem.scale.x = scale;
				particleSystem.scale.z = scale;
				return{
					geometry:geometry,
					particleSystem:particleSystem,
					broken:broken
				};
			}
        </script>
    </body>
</html>