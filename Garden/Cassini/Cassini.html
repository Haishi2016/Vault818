<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hello, World!</title>
        <style>
            body {margin:0;}
            canvas {width:100%; height:100%}
			.info{
				position: absolute;
				left: 10px;
				top:10px;
				color:white;
				font-family:Arial, Helvetica, sans-serif;
				font-size: 40pt;
			}
        </style>
    </head>
    <body>
		<div id="info" class="info">
			# of Containers: <span id="containerCount" class="count">0</span>
		</div>
		<script src="three.js"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				gl_Position = projectionMatrix * mvPosition;
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4(color * vColor, 0.5 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
		</script>
		<script type="application/x-glsl" id="sky-vertex">  
			varying vec2 vUV;
			void main() {  
			  vUV = uv;
			  vec4 pos = vec4(position, 1.0);
			  gl_Position = projectionMatrix * modelViewMatrix * pos;
			}
		</script>
		<script type="application/x-glsl" id="sky-fragment">  
			uniform sampler2D texture;  
			varying vec2 vUV;	
			void main() {  
			  vec4 sample = texture2D(texture, vUV);
			  gl_FragColor = vec4(sample.xyz / 2.0, sample.w);
			}
		</script>  
        <script>
            var camera, scene, renderer;
			var mesh;
			var rings = [];
			var startingY = 140;
			var startingScale = 2;
			var closeStep = 2;
			var particles = 8000;
			var uniforms;
			var shaderMaterial;
			var nodes = [];
			var rotationSpeed = 0.005;
			var stage = 0;
			var closestRing = 250;
			var fallSpeed = 10;
			var brokenThreshold = 5000;
			var lastRingIn = false;
			var ringCount = 10;
			var brokenIndex = 3;
			init();
			animate();
			refreshData();
			function refreshData()
			{
				if (stage == 0){
					updateContainerCount(900000);
					stage++;
				} else if (stage == 10) {	//show adding new ring
					if (!lastRingIn){
						addRing(closestRing + (ringCount-1) * 25, startingY,startingScale);
						lastRingIn = true;
						updateContainerCount(1000000);
					}
					stage++;
				} else if (stage == 20) { //show ring broken
					updateContainerCount(800000);
					breakRing(brokenIndex, closestRing + brokenIndex * 25, 20, 1);
					stage++;
				} else if (stage == 30){ //show ring healing
					updateContainerCount(900000);
					healRing(brokenIndex, closestRing + brokenIndex * 25, 20, 1);
					stage = 0;
				} else 
					stage++;
				for (var i = 0; i < ringCount-1; i++){
					if (!rings[i])
						addRing(closestRing + i * 25, startingY,startingScale);
				}				
				setTimeout(refreshData, 1000);
			}
			function updateContainerCount(count){
				var lastValue = parseInt($('#containerCount').text());				
				$('#containerCount').text(count);
				$('.count').each(function () {
    				$(this).prop('Counter',lastValue).animate({
        				Counter: $(this).text()
    					}, {
        					duration: 4000,
        					easing: 'swing',
        					step: function (now) {
								if (lastValue > now)
            						$(this).text(Math.floor(now));
								else 
									$(this).text(Math.ceil(now));
        				}
    				});
				});
			}
			function healRing(index, radius, y, scale){
				rings[index].broken = false; 			
			}
			function breakRing(index, radius, y, scale){
				rings[index].broken = true; 
			}
			function updateRing(index){

			}
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;
				camera.position.y = 200;
				camera.position.x = -100;
				camera.lookAt(new THREE.Vector3(-200,0,0));
				scene = new THREE.Scene();

				uniforms = {
					color:     { value: new THREE.Color( 0xffffff ) },
					texture:   { value: new THREE.TextureLoader().load( "texture/spark1.png" ) }
				};

				shaderMaterial = new THREE.ShaderMaterial( {
					uniforms:       uniforms,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					blending:       THREE.AdditiveBlending,
					depthTest:      true,
					depthWrite:     false,
					transparent:    true
				});

				var saturnMatrial = new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load( 'texture/saturn.png' )});
				var geometry = new THREE.SphereBufferGeometry( 200, 200, 200 );
				mesh = new THREE.Mesh( geometry, saturnMatrial);
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				scene.add( mesh );

				var light = new THREE.DirectionalLight( 0xffffff,1);
				light.position.set( -300, 300, 500 );
				light.position.multiplyScalar( 30 );
				light.color.setHSL( 0.1, 1, 0.95 );
				light.castShadow = true;
				
				scene.add( light );								

				var skyGeometry = new THREE.SphereGeometry(600, 60, 40);  
				var skyUniforms = {  
					texture: { type: 't', value: THREE.ImageUtils.loadTexture('texture/universe.png') }
				};


				var skyMaterial = new THREE.ShaderMaterial( {  
  					uniforms:       skyUniforms,
  					vertexShader:   document.getElementById('sky-vertex').textContent,
  					fragmentShader: document.getElementById('sky-fragment').textContent,
					
				});

				skyBox = new THREE.Mesh(skyGeometry, skyMaterial);  
				skyBox.scale.set(-1, 1, 1);  
				skyBox.eulerOrder = 'XZY';  				
				skyBox.renderDepth = 100000.0;  
				
				scene.add(skyBox);  

				renderer = new THREE.WebGLRenderer();
				//renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.autoClearColor = false;
				document.body.appendChild( renderer.domElement );
								
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				var time = Date.now() * 0.005;
				requestAnimationFrame( animate );
				mesh.rotation.y -= rotationSpeed;
				rings.forEach((r)=>{
					if (r.particleSystem.position.y > 20)
						r.particleSystem.position.y -= closeStep;
					if (r.particleSystem.scale.x > 1){
						r.particleSystem.scale.x -= (startingScale-1) * closeStep/(startingY-20);
						r.particleSystem.scale.z -= (startingScale-1) * closeStep/(startingY-20);
					}					
					r.particleSystem.rotation.y -=rotationSpeed;

					var sizes = r.geometry.attributes.size.array;
					for ( var i = 0; i < particles; i++ ) {
							sizes[ i ] = 10 * ( 1 + Math.sin( 0.1 * i + time ) );
					}	
					r.geometry.attributes.size.needsUpdate = true;					
					
					var colors = r.geometry.attributes.customColor.array;
					var positions = r.geometry.attributes.position.array;
					for (var j = 0; j < 100; j++) {
						var i = Math.floor(Math.random() * particles);
						var col = Math.random() * 255.0;
						if (r.broken){
							positions[ i*3+ 0] = r.fallRadiuses[i] * Math.cos(r.angles[i]);
							positions[ i*3+ 1] = 0.0;
							positions[ i*3+ 2] = r.fallRadiuses[i] * Math.sin(r.angles[i]);
							colors[ i*3+ 0] = colors[ i*3+ 0] * 0.8;
							colors[ i*3+ 1] = 0.0;
							colors[ i*3+ 2] = 0.0;
							if (r.fallRadiuses[i]>=200)
								r.fallRadiuses[i] -=fallSpeed;
						} else {
							positions[ i*3+ 0] = r.radiuses[i] * Math.cos(r.angles[i]);
							positions[ i*3+ 1] = 0.0;
							positions[ i*3+ 2] = r.radiuses[i] * Math.sin(r.angles[i]);
							if ( (r.angles[i] - mesh.rotation.y) % (Math.PI*3) >= Math.PI/2 && (r.angles[i] - mesh.rotation.y) % (Math.PI*2)<= Math.PI)
							{
								colors[ i*3+ 0] = col * 0.2;
								colors[ i*3+ 1] = col * 0.3;
								colors[ i*3+ 2] = col;
							}
							else
							{
								colors[ i*3+ 0] = Math.min(0.2, col * 0.02);
								colors[ i*3+ 1] = Math.min(0.2, col * 0.03);
								colors[ i*3+ 2] = Math.min(0.2, col * 0.1);
							}
							r.fallRadiuses[i]=r.radiuses[i];
						}
					}
					r.geometry.attributes.customColor.needsUpdate = true;					
					r.geometry.attributes.position.needsUpdate = true;					
				});
				renderer.render( scene, camera );
			}
	
			function addRing(radius, y, scale){
				var ring = makeRing(radius, y, scale, false);
				scene.add( ring.particleSystem );
				rings.push(ring);
			}
			function makeRing(radius, y, scale, broken){
				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array( particles * 3 );
				var colors = new Float32Array( particles * 3 );
				var sizes = new Float32Array( particles );
				var color = new THREE.Color();
				var angles = [];
				var radiuses = [];
				var fallRadiuses = [];
				for ( var i = 0, i3 = 0; i < particles; i ++, i3 += 3 ) {
					var angle = Math.random() * Math.PI * 2;
					var ringSize= Math.random() * 20 + radius;
					positions[ i3 + 0 ] = ringSize * Math.cos(angle);
					positions[ i3 + 1 ] = 0;
					positions[ i3 + 2 ] = ringSize * Math.sin(angle);

					color.setHSL( i / particles, 1.0, 0.5 );
					var col = Math.random() * 255.0;
					if (broken) {
						colors[ i3 + 0 ] = col; //color.r;
						colors[ i3 + 1 ] = 0.0; //color.g;
						colors[ i3 + 2 ] = 0.0; //color.b;
					} else {
						colors[ i3 + 0 ] = col * 0.2; //color.r;
						colors[ i3 + 1 ] = col * 0.3; //color.g;
						colors[ i3 + 2 ] = col; //color.b;
					}
					sizes[ i ] = 10;
					angles.push(angle);
					radiuses.push(ringSize);
					fallRadiuses.push(ringSize);
				}
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
				var particleSystem = new THREE.Points( geometry, shaderMaterial );
				particleSystem.position.y = y;
				particleSystem.scale.x = scale;
				particleSystem.scale.z = scale;
				return{
					geometry:geometry,
					particleSystem:particleSystem,
					broken:broken,
					angles:angles,
					radiuses:radiuses,
					fallRadiuses:fallRadiuses
				};
			}
        </script>
    </body>
</html>